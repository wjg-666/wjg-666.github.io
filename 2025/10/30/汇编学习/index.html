

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/">
  <link rel="icon" href="/">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="wjg">
  <meta name="keywords" content="blog, tech">
  
    <meta name="description" content="经过学长学姐的点拨，还是觉得应当先学汇编，这里就采用一下学姐的笔记（https:&#x2F;&#x2F;buutt3rf1y.github.io） 一、基础知识1.1 机器语言1.2 汇编语言的产生汇编语言的主体指令是汇编指令，汇编指令是机器指令的助记符，每个汇编指令对应一条机器指令。 1.3 汇编语言的组成 汇编指令（机器指令的助记符） 伪指令（没有对应的机器指令，由汇编器处理） 符号指令（变量、常量等）  1.4">
<meta property="og:type" content="article">
<meta property="og:title" content="汇编学习">
<meta property="og:url" content="https://wjg-666.github.io/2025/10/30/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="wjg_blog">
<meta property="og:description" content="经过学长学姐的点拨，还是觉得应当先学汇编，这里就采用一下学姐的笔记（https:&#x2F;&#x2F;buutt3rf1y.github.io） 一、基础知识1.1 机器语言1.2 汇编语言的产生汇编语言的主体指令是汇编指令，汇编指令是机器指令的助记符，每个汇编指令对应一条机器指令。 1.3 汇编语言的组成 汇编指令（机器指令的助记符） 伪指令（没有对应的机器指令，由汇编器处理） 符号指令（变量、常量等）  1.4">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wjg-666.github.io/images/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/c92c75e501ca30e3.png">
<meta property="og:image" content="https://wjg-666.github.io/images/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/e95d6014994bccc2.png">
<meta property="og:image" content="https://wjg-666.github.io/images/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/7abce8d3ed075e5c.png">
<meta property="og:image" content="https://wjg-666.github.io/images/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/2ec88a03c45bf2ad.png">
<meta property="og:image" content="https://wjg-666.github.io/images/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/dac4293593baecdf.png">
<meta property="og:image" content="https://wjg-666.github.io/images/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/94ec61152f16187c.png">
<meta property="og:image" content="https://wjg-666.github.io/images/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/fc40b0af9b9b9006.png">
<meta property="og:image" content="https://wjg-666.github.io/images/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/13d635b29f0a5e87.png">
<meta property="og:image" content="https://wjg-666.github.io/images/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/1499879a-4532-4dcb-92bf-1bf1c37f50e2.png">
<meta property="og:image" content="https://wjg-666.github.io/images/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/efb17885fa7dfbc1.png">
<meta property="og:image" content="https://wjg-666.github.io/images/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/b4e62b03ac53ddf3.png">
<meta property="article:published_time" content="2025-10-30T05:52:06.000Z">
<meta property="article:modified_time" content="2025-11-06T09:33:57.906Z">
<meta property="article:author" content="wjg">
<meta property="article:tag" content="学习">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://wjg-666.github.io/images/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/c92c75e501ca30e3.png">
  
  
  
  <title>汇编学习 - wjg_blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"wjg-666.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":"Si1PQUTYPX1DeZCU0JiicTH0-gzGzoHsz","app_key":"EMxTCg3lvdJ3026UxKY3sACf","server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Wjg 的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="汇编学习"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-30 13:52" pubdate>
          2025年10月30日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          27k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          229 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">汇编学习</h1>
            
            
              <div class="markdown-body">
                
                <p>经过学长学姐的点拨，还是觉得应当先学汇编，这里就采用一下学姐的笔记（<a target="_blank" rel="noopener" href="https://buutt3rf1y.github.io/">https://buutt3rf1y.github.io</a>）</p>
<h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><h2 id="1-1-机器语言"><a href="#1-1-机器语言" class="headerlink" title="1.1 机器语言"></a>1.1 机器语言</h2><h2 id="1-2-汇编语言的产生"><a href="#1-2-汇编语言的产生" class="headerlink" title="1.2 汇编语言的产生"></a>1.2 汇编语言的产生</h2><p>汇编语言的主体指令是汇编指令，汇编指令是机器指令的助记符，每个汇编指令对应一条机器指令。</p>
<h2 id="1-3-汇编语言的组成"><a href="#1-3-汇编语言的组成" class="headerlink" title="1.3 汇编语言的组成"></a>1.3 汇编语言的组成</h2><ul>
<li>汇编指令（机器指令的助记符）</li>
<li>伪指令（没有对应的机器指令，由汇编器处理）</li>
<li>符号指令（变量、常量等）</li>
</ul>
<h2 id="1-4-存储器"><a href="#1-4-存储器" class="headerlink" title="1.4 存储器"></a>1.4 存储器</h2><p>cpu、内存、磁盘</p>
<h2 id="1-5-指令和数据"><a href="#1-5-指令和数据" class="headerlink" title="1.5 指令和数据"></a>1.5 指令和数据</h2><p>指令和数据在内存中存储时，没有区别，都是二进制数。</p>
<p>指令是用来控制 cpu 工作的，数据是用来被指令操作的。</p>
<h2 id="1-6-存储单元"><a href="#1-6-存储单元" class="headerlink" title="1.6 存储单元"></a>1.6 存储单元</h2><p>存储器分为若干个存储单元，每个存储单元有一个唯一的地址，地址是从 0 开始的连续的整数。</p>
<h2 id="1-7-CPU对存储器的读写"><a href="#1-7-CPU对存储器的读写" class="headerlink" title="1.7 CPU对存储器的读写"></a>1.7 CPU对存储器的读写</h2><p>CPU对数据进行读写，需要和外部器件进行信息交互：</p>
<ul>
<li>存储单元地址（地址信息）</li>
<li>器件的选择，读或写命令（控制信息）</li>
<li>读或写的数据（数据信息）</li>
</ul>
<p>连接CPU和其他芯片</p>
<h2 id="1-8-地址总线"><a href="#1-8-地址总线" class="headerlink" title="1.8 地址总线"></a>1.8 地址总线</h2><p>地址总线是用来传送地址信息的总线，地址总线的宽度决定了 cpu 可以访问的内存地址空间的大小。</p>
<p>例如，一个 32 位的 cpu 地址总线宽度为 32 位，那么它可以访问的内存地址空间为 2^32 个字节，即 4GB。</p>
<h2 id="1-9-数据总线"><a href="#1-9-数据总线" class="headerlink" title="1.9 数据总线"></a>1.9 数据总线</h2><p>数据总线是用来传送数据信息的总线，数据总线的宽度决定了 cpu 一次可以传送的数据位数。</p>
<p>例如，一个 32 位的 cpu 数据总线宽度为 32 位，那么它一次可以传送 32 位的数据，即 4 个字节。</p>
<h2 id="1-10-控制总线"><a href="#1-10-控制总线" class="headerlink" title="1.10 控制总线"></a>1.10 控制总线</h2><p>控制总线是用来传送控制信息的总线，控制总线的宽度决定了 cpu 一次可以传送的控制信号位数。</p>
<p>例如，一个 32 位的 cpu 控制总线宽度为 32 位，那么它一次可以传送 32 位的控制信号。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>1.汇编指令是机器指令的助记符，每个汇编指令对应一条机器指令;<br>2.每一种CPU都有字节的汇编指令集;<br>3，CPU可以直接使用的信息在存储器中存放;<br>4.在存储器中指令和数据没有任何区别，都是二进制信息;<br>5.存储单元从零开始存储顺序编号;<br>6.每个存储单元的大小是一个字节（8位）;<br>7.每一个CPU芯片都有许多管脚，管脚和总线相连;</p>
<h2 id="1-11-主板、接口卡"><a href="#1-11-主板、接口卡" class="headerlink" title="1.11 主板、接口卡"></a>1.11 主板、接口卡</h2><h2 id="1-14-各类存储器芯片"><a href="#1-14-各类存储器芯片" class="headerlink" title="1.14 各类存储器芯片"></a>1.14 各类存储器芯片</h2><ul>
<li>随机存储器（RAM）</li>
<li>只读存储器（ROM）</li>
<li>缓存存储器（Cache）</li>
</ul>
<p>装有BOIS的ROM</p>
<p>BOIS：基本输入输出系统</p>
<h2 id="1-15内存地址空间"><a href="#1-15内存地址空间" class="headerlink" title="1.15内存地址空间"></a>1.15内存地址空间</h2><p>存储器在物理上是独立器件，相同点：都通过CPU和总线相连，CPU进行读写时都通过控制线发出内存读写命令</p>
<h1 id="二、寄存器（CPU工作原理）"><a href="#二、寄存器（CPU工作原理）" class="headerlink" title="二、寄存器（CPU工作原理）"></a>二、寄存器（CPU工作原理）</h1><p>一个16位寄存器可以存储数据最大值为2^16-1&#x3D;65535</p>
<h2 id="2-1通用寄存器"><a href="#2-1通用寄存器" class="headerlink" title="2.1通用寄存器"></a>2.1通用寄存器</h2><p>AX的低八位（0位-7位）构成了AL寄存器，高八位（8位-15位）构成了AH寄存器。</p>
<p>AH和AL寄存器是可以独立使用的8位寄存器。</p>
<h2 id="2-2-汇编指令"><a href="#2-2-汇编指令" class="headerlink" title="2.2 汇编指令"></a>2.2 汇编指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ax,18      ;将18送入ax寄存器     AX=18<br>mov ah,78      ;将78送入ah寄存器     AH=78<br>add ax,8       ;将寄存器AX中的数值加8     AX=26<br>mov ax,bx      ;将寄存器BX中的数值送入AX寄存器     AX=BX<br>add ax,bx      ;将寄存器AX中的数值与寄存器BX中的数值相加     AX=AX+BX<br></code></pre></td></tr></table></figure>
<h2 id="2-3-物理地址"><a href="#2-3-物理地址" class="headerlink" title="2.3 物理地址"></a>2.3 物理地址</h2><p>CPU访问内存单元时给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间，这个唯一地址成为物理地址</p>
<h2 id="2-4-16位结构的CPU"><a href="#2-4-16位结构的CPU" class="headerlink" title="2.4 16位结构的CPU"></a>2.4 16位结构的CPU</h2><p>16位结构运算器一次最多可以处理16位数据，寄存器最大宽度为16位，寄存器和运算器之间的通路是16位的。</p>
<p><strong>地址加法器工作原理</strong></p>
<p>地址加法器合成物理地址的方法：<strong>物理地址&#x3D;段地址*16+偏移地址</strong></p>
<p>移位次数和各种形式数据的关系：几进制左移就乘以几（比如二进制左移*2）</p>
<h2 id="2-5-段的概念"><a href="#2-5-段的概念" class="headerlink" title="2.5 段的概念"></a>2.5 段的概念</h2><p>将若干地址连续的内存单元看成一个段</p>
<ul>
<li>一个段的起始地址一定是16的倍数</li>
<li>偏移地址位16位，16位地址的寻址能力为64k，所以一个段的最大长度为64k，2^16&#x3D;64k</li>
</ul>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>CPU访问内存单元时，必须提供物理地址<br>CPU可以通过不同的段地址和偏移地址组成物理地址</p>
<h2 id="2-6段寄存器"><a href="#2-6段寄存器" class="headerlink" title="2.6段寄存器"></a>2.6段寄存器</h2><p>段寄存器是用来存放段地址的寄存器，每个段寄存器只能存放一个段地址。</p>
<p>8086CPU有四个段寄存器：CS、DS、ES、SS，8086CPU要访问内存时，由这四个段寄存器提供内存单元的段地址。</p>
<p>CS：代码段寄存器<br>DS：数据段寄存器<br>ES：额外数据段寄存器<br>SS：栈段寄存器</p>
<h2 id="2-7-CS和IP"><a href="#2-7-CS和IP" class="headerlink" title="2.7 CS和IP"></a>2.7 CS和IP</h2><p>CPU将CS和IP中的内容当作指令的段地址和偏移地址，组成指令的物理地址。<br><strong>CS：代码段寄存器（存放指令的段地址）</strong><br><strong>IP：指令指针寄存器（存放指令的偏移地址）</strong><br>同时修改CS和IP的值，就可以实现指令的跳转。<br><strong>jmp 段地址:偏移地址</strong>、</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">jmp 2AE3:3      ;跳到2AE33<br><br>jmp 3:0B16      ;跳到0B46H   3=0003H<br></code></pre></td></tr></table></figure>
<p>以第一个举例：物理地址&#x3D;2AE3*16+3&#x3D;2AE30+0003&#x3D;2AE33</p>
<p>以第二个举例：物理地址&#x3D;3*16+0B16&#x3D;00030H+0B16&#x3D;00B46H</p>
<p>功能：用指令中给出的段地址修改 CS，偏移地址修改 IP</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">仅修改ip内容：jmp到某一个合法寄存器<br>            jmp ax（类似mov ip,ax）<br>            jmp bx（类似mov ip,bx）<br></code></pre></td></tr></table></figure>
<p>比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ax,200H<br>jmp ax<br></code></pre></td></tr></table></figure>
<p>功能：用寄存器中的值修改ip</p>
<h2 id="2-8-代码段"><a href="#2-8-代码段" class="headerlink" title="2.8 代码段"></a>2.8 代码段</h2><p>将一组内存单元定义为一个段</p>
<p>CPU只认被CS:IP指向的内存单元为指令</p>
<h1 id="三、寄存器（内存访问）"><a href="#三、寄存器（内存访问）" class="headerlink" title="三、寄存器（内存访问）"></a>三、寄存器（内存访问）</h1><h2 id="3-1-内存中字的存储"><a href="#3-1-内存中字的存储" class="headerlink" title="3.1 内存中字的存储"></a>3.1 内存中字的存储</h2><p>内存中字的存储：</p>
<ul>
<li>小端存储：低地址存放低字节，高地址存放高字节</li>
<li>大端存储：高地址存放高字节，低地址存放低字节</li>
</ul>
<p>字型考虑两个字节</p>
<p>两个连续的内存单元，N号单元和N+1可以看成两个内存单元，也可以看成一个地址为N的子单元中的高位字节的单元和低位字节单元。</p>
<h2 id="3-2-DS和-address"><a href="#3-2-DS和-address" class="headerlink" title="3.2 DS和[address]"></a>3.2 DS和[address]</h2><p>DS段寄存器存放要访问的段地址</p>
<p>mov指令能：<br><strong>1.将数据直接送入寄存器</strong><br><strong>2.将寄存器的内容送入另一个寄存器</strong><br><strong>3.将内存单元的内容送入寄存器</strong></p>
<p>mov指令能将<strong>一个内存单元的内容</strong>送入一个寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov 寄存器名,内存单元地址<br>e.g<br>mov bx,1000H<br>mov ds,bx<br>mov al,[0]      ;内存单元偏移地址为0，段地址默认放在ds中<br>mov ds,1000H    ;错误表达<br>8086CPU不支持直接将数据送入段寄存器的操作，用bx进行中转<br></code></pre></td></tr></table></figure>

<p><strong>数据-&gt;通用寄存器-&gt;段寄存器</strong></p>
<p>内存单元到寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov 寄存器名,内存单元地址<br></code></pre></td></tr></table></figure>

<p>寄存器到内存单元</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov 内存单元地址,寄存器名<br></code></pre></td></tr></table></figure>

<p>将a1中的数据传入内存单元10000H中<br>10000H-&gt;1000:0地址为1000H，偏移地址为0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov bx,1000H<br>mov ds,bx<br>mov [0],a1<br></code></pre></td></tr></table></figure>

<h2 id="3-3-字的传送"><a href="#3-3-字的传送" class="headerlink" title="3.3 字的传送"></a>3.3 字的传送</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov bx,1000H<br>mov ds,bx<br>mov ax,[0]      ;1000:0中的字型数据送入ax寄存器<br>mov [0],cx      ;cx中的十六位数据传送到1000:0中<br></code></pre></td></tr></table></figure>
<p><img src="/images/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/c92c75e501ca30e3.png" srcset="/img/loading.gif" lazyload><br><img src="/images/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/e95d6014994bccc2.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="3-4-mov、add、sub指令"><a href="#3-4-mov、add、sub指令" class="headerlink" title="3.4 mov、add、sub指令"></a>3.4 mov、add、sub指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov/add/sub 寄存器,数据      ;mov ax,8<br>mov/add/sub 寄存器,寄存器      ;mov ax,bx<br>mov/add/sub 寄存器,内存单元      ;mov ax,[0]<br>mov/add/sub 内存单元,寄存器      ;mov [0],ax<br>mov/add/sub 段寄存器,寄存器      ;mov ds,bx<br></code></pre></td></tr></table></figure>
<h2 id="3-5-数据段"><a href="#3-5-数据段" class="headerlink" title="3.5 数据段"></a>3.5 数据段</h2><p>将123B0H-123B9H的内存单元定义为数据段，累加这个数据段的前三个单元数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ax,123BH<br>mov ds,ax      ;将123BH作为数据段的段地址<br>mov al,0       ;用al来存放累计结果<br>mov al,[0]      ;将数据段的第一个单元（偏移地址为0）中的数据送入al<br>add al,[1]      ;以此类推<br>add al,[2]<br></code></pre></td></tr></table></figure>
<p>eg.写几条指令，累加数据段中的前三个字型数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ax,123BH<br>mov ds,ax      ;将123BH作为数据段的段地址<br>mov ax,0       ;用ax来存放累计结果<br>mov ax,[0]      ;将数据段的第一个单元（偏移地址为0）中的数据送入ax<br>add ax,[2]      ;以此类推<br>add ax,[4]<br>//一个字占两个单元16位，所以偏移地址为0和2和4<br></code></pre></td></tr></table></figure>
<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>1.字在内存中存储时需要两个连续的内存单元，低位字节放在低地址，高位字节放在高地址<br>2.mov指令中只给出单元的偏移地址，段地址默认放在ds中<br>3.内存和寄存器传字符型数据时，高地址单元和高8位寄存器对应，低地址单元和低8位寄存器对应<br>4.mov&#x2F;add&#x2F;sub 有两个操作对象指令，jmp只有一个</p>
<h2 id="3-6-栈"><a href="#3-6-栈" class="headerlink" title="3.6 栈"></a>3.6 栈</h2><p><strong>先进后出</strong></p>
<p>栈段寄存器：SS<br>栈指针寄存器：SP<br>栈顶：SS:SP<br>栈底：固定不变</p>
<h2 id="3-7-CPU提供的栈机制"><a href="#3-7-CPU提供的栈机制" class="headerlink" title="3.7 CPU提供的栈机制"></a>3.7 CPU提供的栈机制</h2><ul>
<li>8086CPU入栈和出栈都是以字为单位（16位）</li>
<li>push ax是将寄存器的数据送入栈中，pop ax是将栈顶数据弹出到ax寄存器中</li>
<li>段寄存器SS和寄存器SP，栈顶的段地址放在SS中，偏移地址放在SP中，CPU从SS和SP中得到栈顶的地址</li>
<li>任意时刻，SS:SP指向栈顶</li>
</ul>
<p>push ax 执行步骤：<br>1） SP&#x3D;SP-2;SS:SP指向当前栈顶前面的单元，以此为新栈顶</p>
<p>2） 将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶<br><img src="/images/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/7abce8d3ed075e5c.png" srcset="/img/loading.gif" lazyload><br>将10000H-1000FH定义为栈段,SS&#x3D;1000H,栈空间大小为16字节。任意时刻SS:SP指向栈顶，当栈中只有一个元素时，SS&#x3D;1000H,SP&#x3D;000EH。栈为空，就相当于栈中唯一一个元素出栈，出栈后，SP&#x3D;SP+2，SP原来为000EH，后SP&#x3D;0010H，所以栈为空时，SS&#x3D;1000H,SP&#x3D;0010H<br><img src="/images/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/2ec88a03c45bf2ad.png" srcset="/img/loading.gif" lazyload><br>当栈为空时，也就不存在栈顶元素。SS:SP就只能指向最底部单元下面的单元，该单元的偏移地址为栈最底部的子单元的偏移地址+2(000EH+0002H)，栈最底部子单元地址为1000:000EH，所以栈为空时，SP&#x3D;0010H</p>
<p>pop ax 步骤：<br>1） 将SS:SP指向的内存单元中的内容送入ax寄存器中</p>
<p>2） SP&#x3D;SP+2;SS:SP指向当前栈顶后面的单元，以此为新栈顶<br><img src="/images/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/dac4293593baecdf.png" srcset="/img/loading.gif" lazyload><br>出栈后，栈顶元素为1000:000EH，SP&#x3D;000EH，SS:SP指向新栈顶1000EH，1000CH处的2266H依然存在。但已经不在栈中。当再次执行push等入栈操作后，SS:SP移至1000CH，并写入新的数据，将被覆盖</p>
<h2 id="3-8-栈顶超界问题"><a href="#3-8-栈顶超界问题" class="headerlink" title="3.8 栈顶超界问题"></a>3.8 栈顶超界问题</h2><p>注意入栈出栈时超界问题</p>
<h2 id="3-9-push、pop指令"><a href="#3-9-push、pop指令" class="headerlink" title="3.9 push、pop指令"></a>3.9 push、pop指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">push 寄存器      ;将寄存器中的数据送入栈中<br>pop 寄存器       ;将栈顶数据弹出到寄存器中<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">push 段寄存器    ;将段寄存器中的数据送入栈中<br>pop 段寄存器     ;用段寄存器接收数据<br>push 内存单元    ;将内存单元中的数据送入栈中<br>pop 内存单元     ;用内存单元接收数据<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm">e.g.<br>mov ax,1000H<br>mov ds,ax<br>push [0]      ;将1000:0中的数据送入栈中<br>pop [2]       ;出栈的数据放到1000:2中<br></code></pre></td></tr></table></figure>
<p>指令执行时，CPU要知道内存单元的地址，可以在push、pop指令中给出内存单元的偏移地址，段指令在执行时，CPU可以从ds中获得</p>
<p>e.g.<br>1.将 10000H-1000FH这段空间当栈，初始状态栈为空，将AX、BX、DX中的数据入栈</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ax,1000H       ;将1000H作为栈段的段地址，SS=1000H<br>mov ss,ax<br>mov sp,0010H      设置栈顶的偏移地址，栈为空，所以SP=0010H<br>push ax<br>push bx<br>push dx<br></code></pre></td></tr></table></figure>
<p>2.将10000H-1000FH这段空间当栈，初始状态是空，AX&#x3D;001AH，BX&#x3D;001BH，将AX、BX的数据入栈，然后将AX、BX清零，从栈中恢复AX、BX原来的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ax,1000H<br>mov ss,ax<br>mov sp,0010H      ;初始化栈<br><br>mov ax,001AH<br>mov bx,001BH<br><br>push ax<br>push bx      ;ax,bx入栈<br><br>sub ax,ax<br>sub bx,bx      ;将ax,bx清零,也可以用 mov ax,0; mov bx,0<br><br>pop bx<br>pop ax      ;恢复数据，因为是先进后出，所以当前栈顶为bx中的内容001BH,ax中的内容在栈顶下面，所以先pop bx 再pop ax<br></code></pre></td></tr></table></figure>
<h2 id="3-10-栈段"><a href="#3-10-栈段" class="headerlink" title="3.10 栈段"></a>3.10 栈段</h2><p>一段内存当作栈，所以叫栈段<br>1.将10000H-1000FH中的八个字逆序复制到20000H-2000FH中<br><img src="/images/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/94ec61152f16187c.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ax,1000H<br>mov ds,ax<br>mov ax,2000H<br>mov ss,ax<br>mov sp,0010H      ;初始化栈<br>push [0]<br>push [2]<br>push [4]<br>push [6]      ;将10000H-1000FH中的八个字入栈<br>push [8]<br>push [A]<br>push [C]<br>push [E]      ;先顺序将10000H-1000FH中的八个字入栈<br></code></pre></td></tr></table></figure>
<p>逆序复制到20000H-2000FH中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ax,2000H<br>mov ds,ax<br>mov ax,1000H<br>mov ss,ax<br>mov sp,0010H      ;初始化栈<br>pop [E]<br>pop [C]<br>pop [A]<br>pop [8]      ;出栈顺序与入栈顺序相反，所以先出栈的是10000H-1000FH中的最后一个字，即[E]<br>pop [6]<br>pop [4]<br>pop [2]<br>pop [0]      ;将20000H-2000FH中的八个字出栈，完成逆序复制<br></code></pre></td></tr></table></figure>

<h1 id="四、第一个程序"><a href="#四、第一个程序" class="headerlink" title="四、第一个程序"></a>四、第一个程序</h1><h2 id="4-2-源程序"><a href="#4-2-源程序" class="headerlink" title="4.2 源程序"></a>4.2 源程序</h2><h3 id="1-伪指令"><a href="#1-伪指令" class="headerlink" title="1.伪指令"></a>1.伪指令</h3><p><strong>汇编语言中有汇编指令和伪指令</strong></p>
<ul>
<li>汇编指令：有对应的机器码指令，可以被编译为机器指令，最终被CPU所执行</li>
<li>伪指令：没有对应的机器指令，不被CPU执行。由编译器执行指令，进行相关编译工作<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asm">assum cs:codesg      ;将代码段codesg和CPU的段寄存器cs联系（假设cs为codesg段）<br>codesg segment      ;定义一个段，段名为codesg<br>		mov ax,0123H<br>		mov bx,0456H<br>		add ax,bx<br>		add ax,ax<br>		mov ax,4c00H<br>		int 21H<br>codesg ends      ;段结束<br>end      ;程序结束<br></code></pre></td></tr></table></figure>
a.segment和ends是成对使用的伪指令，segment和ends定义一个段，格式为:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">段名  segment<br>	:<br>段名  ends<br></code></pre></td></tr></table></figure>
b.end表示一个汇编程序结束</li>
</ul>
<p>c.assume 说明某段寄存器和程序中的某一个用segment…ends定义的段相关联</p>
<h3 id="2-源程序这的程序"><a href="#2-源程序这的程序" class="headerlink" title="2.源程序这的程序"></a>2.源程序这的程序</h3><h3 id="3，标号"><a href="#3，标号" class="headerlink" title="3，标号"></a>3，标号</h3><p>如”codesg”，一个标号代表了一个地址，codesg在segment前面，作为一个段名称，这个名称最终被编译、连接程序处理为一个段的段地址。</p>
<h3 id="4-程序的结构"><a href="#4-程序的结构" class="headerlink" title="4.程序的结构"></a>4.程序的结构</h3><p>编写运算2^3的程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">assum cs:abc<br>abc segment<br>    mov ax,2<br>    add ax,ax<br>    add ax,ax<br>abc ends<br>end<br></code></pre></td></tr></table></figure>
<h3 id="5-程序的返回"><a href="#5-程序的返回" class="headerlink" title="5.程序的返回"></a>5.程序的返回</h3><p>一个程序结束后，将CPU的控制权交换给它得以运行的程序，这个过程称为程序返回</p>
<table>
<thead>
<tr>
<th align="center">目的</th>
<th align="center">相关指令</th>
<th align="center">指令性质</th>
<th align="center">指令执行者</th>
</tr>
</thead>
<tbody><tr>
<td align="center">通知编译器一个段的结束</td>
<td align="center">段名 ends</td>
<td align="center">伪指令</td>
<td align="center">编译时编译器</td>
</tr>
<tr>
<td align="center">通知编译器程序结束</td>
<td align="center">end</td>
<td align="center">伪指令</td>
<td align="center">编译时编译器</td>
</tr>
<tr>
<td align="center">程序返回</td>
<td align="center">mov ax,4c00H int 21H</td>
<td align="center">指令性</td>
<td align="center">执行时CPU</td>
</tr>
</tbody></table>
<h2 id="4-3-编辑源程序"><a href="#4-3-编辑源程序" class="headerlink" title="4.3 编辑源程序"></a>4.3 编辑源程序</h2><p>DOS中有一个程序command.com，这个程序在DOS中称为命令解释器，也就是DOS系统的shell</p>
<p>汇编程序从写出到执行过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">asm -&gt; 编译 -&gt; 1.obj -&gt; 链接 -&gt; 1.exe -&gt; 加载 -&gt; 内存中的程序 -&gt; 运行<br>    (masm)             (link)        (command)        (cpu)<br></code></pre></td></tr></table></figure>

<h1 id="五、-BX-和loop指令"><a href="#五、-BX-和loop指令" class="headerlink" title="五、[BX]和loop指令"></a>五、[BX]和loop指令</h1><p>1.[bx]和[0]类似，偏移地址为0</p>
<p>2.[bx]表示一个内存单元，偏移地址在bx中</p>
<p>3.loop循环</p>
<p>4.”()”符号三种类型:</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">含义</th>
<th align="center">示例</th>
<th align="center">实际汇编写法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">寄存器名</td>
<td align="center">寄存器中的值作为地址</td>
<td align="center">(BX)</td>
<td align="center">[BX]</td>
</tr>
<tr>
<td align="center">段寄存器名</td>
<td align="center">段寄存器中的段地址</td>
<td align="center">(DS)</td>
<td align="center">DS(无需方括号)</td>
</tr>
<tr>
<td align="center">物理地址</td>
<td align="center">20位物理地址</td>
<td align="center">(0x12345)</td>
<td align="center">[0x12345]</td>
</tr>
<tr>
<td align="center">e.g</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asm">ax内容位0010H，可以描述为：(ax)=0010H<br>2000:1000处的内容为0010H，描述为：（21000H）=0010H<br>mov ax,[2]      ;描述为(ax)=((ds)*16+2)<br>mov [2],ax      ;描述为((ds)*16+2)=ax<br>add ax,2		;描述为(ax)=(ax)+2<br>add ax,bx		;描述为(ax)=(ax)+(bx)<br>push ax			;描述为(sp)=(sp)-2,((ss)*16+(sp))=(ax)<br>pop ax			;描述为(ax)=((ss)*16+(sp)),(sp)=(sp)+2<br></code></pre></td></tr></table></figure>
<p>5.”(X)”中表示数据有两种类型:字节和字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">比如(al)、(bl)、(Cl)等得到的数据为字节<br>(ds)、(ax)、(bx)等得到的数据为字<br>(al)=(20000H)，则(20000H)得到的数据为字节型<br>(ax)=(20000H)，则(20000H)得到的数据为字型<br></code></pre></td></tr></table></figure>
<p>6.约定符号idata表示常量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ax,[idata]		;代表mov ax,[1]、mov ax,[2]、mov ax,[3]等<br>mov bx,idata	;代表mov bx,1、mov bx,2、mov bx,3等<br>mov ds,idata	;代表mov ds,1、mov ds,2、mov ds,3等，都是非法指令<br></code></pre></td></tr></table></figure>
<h2 id="5-1-BX"><a href="#5-1-BX" class="headerlink" title="5.1 [BX]"></a>5.1 [BX]</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ax,[bx]<br>bx中存放数据作为一个偏移地址EA，段地址SA默认在ds中，将ax中的数据复制到内存中SA:EA处，即:((ds)*16+(bx))=(ax)<br></code></pre></td></tr></table></figure>
<p>e.g 写出程序执行后，21000H-2100FH单元中的内容<br><img src="/images/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/fc40b0af9b9b9006.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ax,2000H<br>mov ds,ax<br>mov bx,1000H		;ds=2000H,bx=1000H<br><br>mov ax,[bx]			;将2000:1000处的字型数据送入ax中。ax=00BEH<br><br>inc bx<br>inc bx				;bx=1002H<br><br>mov [bx],ax			;ds=2000H,bx=1002H,将ax中的数据送入2000:1002H处。2000:1002H=BEH,2000:1003H=00H<br>inc bx<br>inc bx				;bx=1004H<br><br>mov [bx],ax			;ds=2000H,bx=1004H,将ax中的数据送入2000:1004H处。2000:1004H=BEH,2000:1005H=00H<br><br>inc bx				;bx=1005H<br><br>mov [bx],al			;ds=2000H,bx=1005H,将al中的数据送入2000:1005H处。2000:1005H=BEH<br><br>inc bx				;bx=1006H<br>mov [bx],al			;ds=2000H,bx=1006H,将al中的数据送入2000:1006H处。2000:1006H=BEH<br></code></pre></td></tr></table></figure>
<p><img src="/images/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/13d635b29f0a5e87.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="5-2-Loop指令"><a href="#5-2-Loop指令" class="headerlink" title="5.2 Loop指令"></a>5.2 Loop指令</h2><p>1.格式：loop标号</p>
<p>2.CPU执行指令时要进行两步操作：a.(cx)&#x3D;(cx)-1 b.判断cx中的值，不为零则转至标号处执行程序，如果为零则向下执行</p>
<p>e.g 计算2^2,结果存在ax中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:code<br>code segment<br>	mov ax,2<br>	add ax,ax<br>	mov ax,4c00H<br>	int 21H<br>code ends<br>end<br></code></pre></td></tr></table></figure>
<p>e.g 计算2^12，结果存在ax中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:code<br>code segment<br>	mov ax,2<br><br>	mov cx,11<br>s : add ax,ax			;用s标识了一个地址，地址处有一条指令: add ax,ax<br>	loop s				;判断(cx)=(cx)-1,不为零则转至s处执行程序，为零则向下执行(执行loop s时，首先将(cx)-1，不为零就转到s处)<br>	mov ax,4c00H<br>	int 21H<br>code ends<br>end<br></code></pre></td></tr></table></figure>
<p>cs 和 loop 指令配合实现循环3要点：</p>
<ol>
<li>在cx中存放循环次数</li>
<li>loop指令中的标号所标识地址要在前面</li>
<li>要循环执行的程序段，要写在标号和loop指令的中间<br>框架<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">	mov cx,循环次数<br>s:<br>	循环执行的程序段<br>	loop s<br></code></pre></td></tr></table></figure>
e.g 用加法计算123*236,结果存在ax中<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:code<br>code segment<br>	mov ax,0<br>	mov cx,236<br>s:	add ax,123<br>	loop s<br>	mov ax,4c00H<br>	int 21H<br>code ends<br>end<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="5-5-loop和-bx-的联合应用"><a href="#5-5-loop和-bx-的联合应用" class="headerlink" title="5.5 loop和[bx]的联合应用"></a>5.5 loop和[bx]的联合应用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs asm">	assume cs:code<br>	code segment<br>	mov ax,0ffffH<br>	mov ds,ax<br>	mov bx,0			;初始化ds:bx指向ffff:0<br>	<br>	mov dx,0			;初始化累加寄存器dx,(dx)=0<br><br>	mov cx,12			;初始化循环次数cx,(cx)=12<br><br>s:  mov al,[bx]			;将[bx]单元的值送入低地址中<br>	mov ah,0			;将高地址ah寄存器清零<br>	add dx,ax			;间接向dx中加上((ds)*16+(bx))单元的数值<br>	inc bx				;ds:bx指向下一个单元<br>	loop s<br><br>	mov ax,4c00H<br>	int 21H<br>code ends<br>end<br></code></pre></td></tr></table></figure>
<h2 id="5-6-段前缀"><a href="#5-6-段前缀" class="headerlink" title="5.6 段前缀"></a>5.6 段前缀</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ax,ds:[bx]<br>		cs:[bx]<br>		ss:[bx]<br>		es:[bx]				;将一个内存单元送入ax，这个内存单元长度为2字节，存放一个字，偏移地址在bx，段地址在ds、cs、ss、es中<br>mov ax,ss:[0]<br>		cs:[0]				;将一个内存单元送入ax，这个内存单元长度为2字节，存放一个字，偏移地址在0，段地址在ds、cs、ss、es中<br></code></pre></td></tr></table></figure>
<p>段前缀用于显示地指明内存单元的段地址，如何”ds”,”cs”,”ss”,”es”等</p>
<h2 id="5-7-一段安全的空间"><a href="#5-7-一段安全的空间" class="headerlink" title="5.7 一段安全的空间"></a>5.7 一段安全的空间</h2><ul>
<li>直接向一段内写入内容</li>
<li>这段内容不应存放系统或其他程序的数据或代码，否则写入操作可能会导致系统崩溃或其他问题</li>
<li>DOS方式下，一般情况，0:200-0:2ff空间没有系统或其他程序的数据或代码</li>
<li><strong>要直接向一段内存中写入内容时，使用0:200-0:2ff这段空间</strong></li>
</ul>
<h2 id="5-8-段前缀的使用"><a href="#5-8-段前缀的使用" class="headerlink" title="5.8 段前缀的使用"></a>5.8 段前缀的使用</h2><p>e.g 将内存 ffff:0-ffff:b 单元处的数据复制到0:200-0:20b单元中</p>
<ul>
<li>0:200-0:20b 相当于0020:0-0020:b单元（因为地址值都为00200H,0020bH）</li>
<li>初始化:X&#x3D;0 循环12次: 将ffff:X 单元数据送入0020:X X&#x3D;X+1</li>
<li>原始单元ffff:X 和目标单元0020:X的偏移地址X是变量。用bx存放</li>
<li>将0:200-0:20b 用0020:0-0020:b描述，使目标单元的偏移地址和源始单元的偏移地址从同一数值0开始<br><strong>使用两个寄存器分别存放原始单元 ffff:X和目标单元 0020:X的段地址</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs asm">  assume cs:code<br>  code segment<br>		mov ax,0ffffh<br>		mov ds,ax				;(ds)=0ffffh<br><br>		mov ax,0020h<br>		mov es,ax				;(es)=0020h<br><br>		mov bx,0				;初始化bx为0，此时ds:bx指向ffff:0,es:bx指向0020:0<br><br>		mov cx,12				;初始化循环次数cx,(cx)=12<br><br> s:  	mov dl,[bx]				;(dl)=((ds)*16+(bx)),将ffff:bx中的数据送入dl中<br>		mov es:[bx],dl			;(es)*16+(bx)=(dl),将dl中数据送入0020:bx中<br>		inc bx					;(bx)=(bx)+1<br>		loop s<br><br>		mov ax,4c00H<br>		int 21H<br>code ends<br>end<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="六、包含多个段的程序"><a href="#六、包含多个段的程序" class="headerlink" title="六、包含多个段的程序"></a>六、包含多个段的程序</h1><h2 id="6-1-在代码块中使用数据"><a href="#6-1-在代码块中使用数据" class="headerlink" title="6.1 在代码块中使用数据"></a>6.1 在代码块中使用数据</h2><p>框架</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asm">asume cs:code<br>code segment<br>		:<br>		数据<br>		:<br>start:<br>		:<br>		程序代码<br>		:<br>	mov ax,4c00H<br>	int 21H<br>code ends<br>end<br></code></pre></td></tr></table></figure>
<p>e.g. 计算以下八个数据的和，结果存在ax寄存器中: 0123h、0456h、0789h、0abch、0defh、0321h、0654h、0987h</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:code<br>code segment<br>dw 0123h,0456h,0789h,0abch,0defh,0321h,0654h,0987h			;define word(定义若干个字型数据，占两个字节)<br>start:  mov bx,0<br>		mov ax,0<br><br>		mov cx,8<br>	s:  add ax,cx:[bx]<br>		add bx,2<br>		loop s<br><br>		mov ax,4c00H<br>		int 21H<br>code ends<br>end<br></code></pre></td></tr></table></figure>

<h2 id="6-2-在代码段中使用栈"><a href="#6-2-在代码段中使用栈" class="headerlink" title="6.2 在代码段中使用栈"></a>6.2 在代码段中使用栈</h2><p>利用栈，将数据0123h、0456h、0789h、0abch、0defh、0321h、0654h、0987h入栈，然后出栈，将出栈数据送入cs:10-cs:2F单元中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:codesg<br>codesg segment<br>	dw 0123h,0456h,0789h,0abch,0defh,0321h,0654h,0987h<br>	dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0				;定义16个字型数据，占16个字的内存空间，用于栈空间（所以栈地址就为cs:10h-cs:2fh）<br><br>start: mov ax,cs<br>	mov ss,ax<br>	mov sp,30h				;将栈顶ss:sp指向cs:30h<br>	 <br>	mov bx,0<br>	mov cx,8<br> s: push cs:[bx]<br>	add bx,2<br>	loop s				;以上代码0-15个单元中的8个字符数据依次入栈<br><br>	mov bx,0<br>	mov cx,8<br>s0: pop cs:[bx]<br>	add bx,2<br>	loop s0				;以上代码出栈8个字符数据，依次送入cs:10-cs:2F单元中<br>	 <br>	mov ax,4c00H<br>	int 21H<br>codesg ends<br>end<br></code></pre></td></tr></table></figure>

<h2 id="6-3-将数据、代码、栈放入不同的段"><a href="#6-3-将数据、代码、栈放入不同的段" class="headerlink" title="6.3 将数据、代码、栈放入不同的段"></a>6.3 将数据、代码、栈放入不同的段</h2><p><strong>逆序存放</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:code,ds:data,ss:stack<br>data segment<br>	dw 0123h,0456h,0789h,0abch,0defh,0321h,0654h,0987h			;d定义若干个字型数据，占两个字节<br>data ends<br>stack segment<br>	dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0				;定义16个字型数据，占16个字的内存空间，用于栈空间（偏移地址为00h-1Fh）<br>stack ends<br>code segment<br>start: mov ax,stack<br>	mov ss,ax<br>	mov sp,20h				;将栈顶ss:sp指向cs:20h<br><br>	mov ax,data<br>	mov ds,ax				;ds指向data段<br><br>	mov bx,0				;ds:bx指向data段的00h单元<br><br>	mov cx,8				;初始化循环次数cx,(cx)=8<br>s:  push [bx]<br>	add bx,2<br>	loop s					;以上代码将data段中的8个字型数据依次入栈<br><br>	mov bx,0<br><br>	mov cx,8<br>s0: pop [bx]<br>	add bx,2<br>	loop s0					;以上代码将栈中的8个字型数据依次出栈，送入data段的0-15个单元中<br><br>	mov ax,4c00H<br>	int 21H<br>code ends<br>end start<br></code></pre></td></tr></table></figure>

<h1 id="七、定位内存地址的方法"><a href="#七、定位内存地址的方法" class="headerlink" title="七、定位内存地址的方法"></a>七、定位内存地址的方法</h1><h2 id="7-1-and和or指令"><a href="#7-1-and和or指令" class="headerlink" title="7.1 and和or指令"></a>7.1 and和or指令</h2><ol>
<li><p>and指令:逻辑与，按位进行与运算（两个1才是1）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov al,01010101b<br>and al,00110011b<br>结果:al=00010001b<br></code></pre></td></tr></table></figure>
</li>
<li><p>or指令:逻辑或，按位进行或运算（有一个1就是1）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov al,01010101b<br>or al,00110011b<br>结果:al=01110111b<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="7-3-以字符形式给出的数据"><a href="#7-3-以字符形式给出的数据" class="headerlink" title="7.3 以字符形式给出的数据"></a>7.3 以字符形式给出的数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:code,ds:data<br>data segment<br>	db &#x27;unIX&#x27;				;相当于“db 75H,6EH,49H,58H”,db定义字节变量，类似dw<br>	db &#x27;foRK&#x27;				;相当于“db 66H,6FH,52H,4BH”<br>data ends<br>code segment<br>start: mov al,&#x27;a&#x27;			;mov al,61H<br>	mov bl,&#x27;b&#x27;<br>	mov ax,4c00H<br>	int 21H<br>code ends<br>end start<br></code></pre></td></tr></table></figure>

<h2 id="7-4-大小写转换"><a href="#7-4-大小写转换" class="headerlink" title="7.4 大小写转换"></a>7.4 大小写转换</h2><p>判断二进制的第五位是0还是1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:codesg,ds:datasg<br>datasg segment<br>	db &#x27;BaSiC&#x27;<br>	db &#x27;iNfOrMaTiOn&#x27;<br>datasg ends<br>codesg segment<br>start: mov ax,datasg<br>	mov ds,ax				;设置ds指向datasg段<br><br>	mov bx,0;				;设置(bx)=0,ds:bx指向datasg段的00h单元<br><br>	mov cx,5				;初始化循环次数cx,(cx)=5<br>s:	mov al,[bx]				;将ASCII码从ds:bx所指向的单元取出<br>	and al,11011111b        ;将al中的ASCII码的第五位变为0,变为大写字母<br>	mov [bx],al				;将转换后的ASCII码写回原单元<br>	inc bx					;ds:bx指向下一个字母<br>	loop s <br><br>	mov bx,5				;(bx)=5,ds:bx指向&#x27;iNfOrMaTiOn&#x27;的第一个字母<br>	<br>	mov cx,11<br>s0: mov al,[bx]<br>	or al,00100000b         ;将al中的ASCII码第五位的位置变为1,变为小写<br>	mov [bx],al				;将转换后的ASCII码写回原单元<br>	inc bx					;ds:bx指向下一个字母<br>	loop s0 <br><br>	mov ax,4c00H<br>	int 21H<br>codesg ends<br>end start<br></code></pre></td></tr></table></figure>

<h2 id="7-5-bx-idata"><a href="#7-5-bx-idata" class="headerlink" title="7.5 [bx+idata]"></a>7.5 [bx+idata]</h2><p>[bx+idata]表示一个内存单元，偏移地址为(bx)+idata(bx中的数值加上idata)</p>
<p>mov ax,[bx+200] 的含义</p>
<ul>
<li>将一个内存单元送入ax，内存单元长度为2个字节(字单元)，存放一个字，偏移地址为bx中的数值加上200，段地址在ds中</li>
<li>(ax)&#x3D;((bx)*16+(bx)+200)</li>
<li>mov ax,[200+bx]</li>
</ul>
<p>mov ax,200[bx] 和上面等价<br>mov ax,[bx].200 也与上面等价</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asm">2000:1000 BE 00 06 00 00 00 ...<br>写出下面程序执行后，ax、bx、cx中的内容<br>mov ax,2000H<br>mov ds,ax<br>mov bx,1000H<br><br>mov ax,[bx]					;访问段地址在ds中，(ds)=2000H;偏移地址在bx中，(bx)=1000H;指令执行后(ax)=00BEH<br><br>mov cx,[bx+1]				;偏移地址=(bx)+1=1001H;后(cx)=0600H<br><br>add cx,[bx+2]				;偏移地址=(bx)+2=1002H;后(cx)=0600H+0006H=0606H<br></code></pre></td></tr></table></figure>

<h2 id="7-6-用-bx-idata-的方式进行数组的处理"><a href="#7-6-用-bx-idata-的方式进行数组的处理" class="headerlink" title="7.6 用[bx+idata]的方式进行数组的处理"></a>7.6 用[bx+idata]的方式进行数组的处理</h2><p>将datasg中定义的第一个字符串转换化大写，第二个字符串转换为小写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:codesg,ds:datasg<br>datasg segment<br>	db &#x27;BaSiC&#x27;<br>	db &#x27;MinIX&#x27;<br>datasg ends<br>codesg segment<br>start: 	mov ax,datasg<br>		mov ds,ax<br>		mov bx,0<br><br>		mov cx,5<br>	s:	mov al,0[bx]<br>		and al,11011111b<br>		mov 0[bx],al<br>		mov al,5[bx]<br>		or al,00100000b<br>		mov 5[bx],al<br>		inc bx<br>		loop s<br><br>		mov ax,4c00H<br>		int 21H<br>codesg ends<br>end start<br></code></pre></td></tr></table></figure>

<h2 id="7-7-SI和DI"><a href="#7-7-SI和DI" class="headerlink" title="7.7 SI和DI"></a>7.7 SI和DI</h2><p>SI和DI是8086CPU中和BX功能相近的寄存器，不能分成两个8位寄存器来使用</p>
<p>下面三组实现同一功能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov bx,0<br>mov ax,[bx]<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov si,0<br>mov ax,[si]<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov di,0<br>mov ax,[di]<br></code></pre></td></tr></table></figure>
<p>下面三组实现同一功能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov bx,0<br>mov ax,[di]<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov si,0<br>mov ax,[si+123]<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov di,0<br>mov ax,[di+123]<br></code></pre></td></tr></table></figure>
<p>e.g 用si和di实现将字符串’welcome to masm!复制到它后面的数据中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:codesg,ds:datasg<br>datasg segment<br>	db &#x27;welcome to masm!&#x27;<br>	db &#x27;................&#x27;<br>datasg ends<br>codesg segment<br>start:	mov ax,datasg<br>		mov ds,ax<br>		mov si,0<br>		mov di,16<br>		mov cx,8<br>	s:	mov ax,[si]<br>		mov [di],ax<br>		add si,2<br>		add di,2<br>		loop s<br><br>		mov ax,4c00H<br>		int 21H<br>codesg ends<br>end start				;ds:si指向要复制的原始字符串，用ds:di指向复制的目的空间。用16位寄存器进行内存单元之间的数据传送，一次复制2个字节，循环8次<br></code></pre></td></tr></table></figure>
<p>使用[bx(si或di)+idata]的方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs asm">codesg segment<br>start:	mov ax,datasg<br>		mov ds,ax<br>		mov si,0<br><br>		mov cs,8<br>	s:	mov ax,0[si]<br>		mov 16[si],ax<br>		add si,2<br>		loop s<br>		<br>		mov ax,4c00H<br>		int 21H<br>codesg ends<br>end start				;ds:si指向要复制的原始字符串，用ds:di指向复制的目的空间。用16位寄存器进行内存单元之间的数据传送，一次复制2个字节，循环8次<br></code></pre></td></tr></table></figure>

<h2 id="7-8-bx-si-和-bx-di"><a href="#7-8-bx-si-和-bx-di" class="headerlink" title="7.8 [bx+si]和[bx+di]"></a>7.8 [bx+si]和[bx+di]</h2><p>[bx+si]表示一个内存单元，偏移地址为(bx)+(si)即bx中的数值加上si的数值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ax,[bx+si]<br>将一个内存单元的内容送入ax，内存单元的长度为2个字节(字单元)，存放一个字，偏移地址为bx中的数值加上si的数值,段地址在ds中<br><br>也可写为如下格式<br>mov ax,[bx][si]<br></code></pre></td></tr></table></figure>
<p>e.g 2000:1000 BE 00 06 00 00 00 …,写出ax、bx、cx中的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ax,2000H<br>mov ds,ax<br>mov 1000H<br>mov si,0<br>mov ax,[bx+si]				;段地址在ds中，(ds)=2000H;偏移地址=(bx)+(si)=1000H;指令执行后(ax)=00BEH<br><br>inc si<br>mov cx,[bx+si]				;偏移地址=(bx)+(si)=1001H;执行后(cx)=0600H<br><br>inc si<br>mov di,si<br>add cx,[bx+di]				;偏移地址=(bx)+(di)=1002H;执行后(cx)=0600H+0006H=0606H<br></code></pre></td></tr></table></figure>
<h2 id="7-9-bx-si-idata-和-bx-di-idata"><a href="#7-9-bx-si-idata-和-bx-di-idata" class="headerlink" title="7.9 [bx+si+idata]和[bx+di+idata]"></a>7.9 [bx+si+idata]和[bx+di+idata]</h2><p>[bx+si+idata]表示一个单元，偏移地址为(bx)+(si)+idata(即bx中的数值在加上si中的数值再加上idata)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ax,[bx+si+idata]<br>将内存单元送入ax，偏移地址bx加上si数值再加上idata，段地址在ds中(ax)=((ds)*16+(si)+idata)<br><br>也有下面这些格式<br>mov ax,[bx+200+si]<br>mov ax,[200+bx+si]<br>mov ax,200[bx][si]<br>mov ax,[bx].200[si]<br>mov ax,[bx][si].200<br></code></pre></td></tr></table></figure>
<p>e.g 2000:1000 BE 00 06 00 6A 22 …写出ax、bx、cx的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ax,2000H<br>mov ds,ax<br>mov bx,1000H<br>mov si,0<br>mov ax,[bx+2+si]				;段地址在ds中，(ds)=2000H,偏移地址为1000H+2+0=1002H,(ax)=0006H<br><br>inc si<br>mov cx,[bx+2+si]				;(ds)=2000H,偏移地址=(bx)+2+(si)=1003H,(cx)=6A00H<br><br>inc si<br>mov di,si<br>mov bx,[bx+2+di]				;偏移地址=(bx)+2+di=1004H;(bx)=226AH<br></code></pre></td></tr></table></figure>
<h2 id="7-10"><a href="#7-10" class="headerlink" title="7.10"></a>7.10</h2><ul>
<li>[idata]用<strong>常量</strong>表示地址，可以直接定位一个内存单元</li>
<li>[bx]用变量来表示内存地址，可以间接定位一个内存单元</li>
<li>[bx+idata]用变量和常量表示内存地址，可以在起始地址的基础上用变量间接定位一个内存单元</li>
<li>[bx+si]用两个变量表示地址</li>
<li>[bx+si+idata]用两个变量一个常量表示地址<br>e.g 将datasg段中每个单词的头改为大写字母<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:codesg,ds:datasg<br>datasg segment<br>		db			&#x27;1. file				&#x27;<br>		db			&#x27;2. edit				&#x27;<br>		db			&#x27;3. search				&#x27;<br>		db			&#x27;4. view				&#x27;<br>		db			&#x27;5. options				&#x27;<br>		db			&#x27;6. help				&#x27;<br>datasg ends<br>codesg segment<br>start:	mov ax,datasg<br>		mov ds,ax<br>		mov bx,0<br>		mov cx,6<br>	s:	mov al,[bx+3]<br>		and al,11011111b<br>		mov [bx+3],al<br>		add bx,16<br>		loop s<br><br>		mov ax,4c00H<br>		int 21H<br>codesg ends<br>end start<br></code></pre></td></tr></table></figure>
<img src="/images/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/1499879a-4532-4dcb-92bf-1bf1c37f50e2.png" srcset="/img/loading.gif" lazyload><br>改进程序<br>**一般情况下，需要暂存数据的时候，应该使用栈<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cd:codesg,ds:datasg,ss:stacksg<br>datasg segment<br>		db		&#x27;ibm			&#x27;<br>		db		&#x27;dec			&#x27;<br>		db		&#x27;dos			&#x27;<br>		db		&#x27;vax			&#x27;<br>datasg ends<br><br>stacksg segment<br>		dw 0,0,0,0,0,0,0,0<br>stacksg ends<br><br>codesg segment<br>start: 	mov ax,stacksg<br>		mov ss,ax<br>		mov ax,datasg<br>		mov ds,ax<br>		mov bx,0<br>		mov cx,4<br><br>	s0:	push cx<br>		mov si,0<br>		mov cx,3				;将外层循环cx值压栈<br><br>	s:	mov al,[bx+si]<br>		add al,11011111b<br>		mov [bx+si],al<br>		inc si<br>		loop s<br><br>		add bx,16<br>		pop cx				;从栈顶弹出原cx的值，恢复cx<br>		loop s0				;外层循环的loop指令将cx的值-1<br><br>		mov ax,4c00H<br>		int 21H<br>codesg ends<br>end start<br></code></pre></td></tr></table></figure></li>
</ul>
<p>e.g 将datasg段每个单词前四个字母改为大写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cd:codesg,ss:stacksg,ds:datasg<br>stacksg segment<br>		dw 0,0,0,0,0,0,0,0<br>stacksg ends<br>datasg segment<br>		db			&#x27;1. display		&#x27;<br>		db			&#x27;2. brows		&#x27;<br>		db			&#x27;3. replace		&#x27;<br>		db			&#x27;4. modify		&#x27;<br>datasg ends<br>codesg segment<br>start:	mov ax,datasg<br>		mov ds,ax<br>		mov bx,0<br>		mov cx,4<br><br>	s0:	push cx<br>		mov si,0<br>		mov cx,4<br><br>	s:	mov al,[bx+si+3]<br>		and al,11011111b<br>		mov [bx+si+3],al<br>		inc si<br>		loop s<br><br>		add bx,16<br>		pop cs<br>		loop s0<br><br>		mov ax,4c00H<br>		int 21h<br>codesg ends<br>end start<br></code></pre></td></tr></table></figure>
<h1 id="八、数据处理的两个基本问题"><a href="#八、数据处理的两个基本问题" class="headerlink" title="八、数据处理的两个基本问题"></a>八、数据处理的两个基本问题</h1><p>reg寄存器的集合包括：ax,bx,cx,dx,al,bl,cl,dl,ah,bh,ch,dh,sp,bp,si,di<br>sreg寄存器的集合包括：cs,ds,es,ss</p>
<h2 id="8-1-bx、si、di、bp"><a href="#8-1-bx、si、di、bp" class="headerlink" title="8.1 bx、si、di、bp"></a>8.1 bx、si、di、bp</h2><ol>
<li><p>在8086CPU中，<strong>只有这四个寄存器可以在”[…]”中进行内存单元寻址</strong></p>
</li>
<li><p>在[…]中，这4个寄存器可以单个出现，或只能以4种组合出现：&#x3D;&#x3D;bx+si、bx+di、bp+si、bp+di&#x3D;&#x3D;</p>
</li>
<li><p>只要在[…]中使用寄存器bp，而指令中没有显性地给出段地址，<strong>段地址默认在ss中</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ax,[bp]						;(ax)=((ss)*16+(bp))<br>mov ax,[bp+idata]				;(ax)=((ss)*16+(bp)+idata)<br>mov ax,[bp+si]					;(ax)=((ss)*16+(bp)+(si))<br>mov ax,[bp+si+idata]			;(ax)=((ss)*16+(bp)+(si)+idata)<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="8-3-数据位置的表达"><a href="#8-3-数据位置的表达" class="headerlink" title="8.3 数据位置的表达"></a>8.3 数据位置的表达</h2><ol>
<li><p>立即数(idata)</p>
</li>
<li><p>寄存器</p>
</li>
<li><p>段地址(SA)和偏移地址(EA)<br>存放段地址的寄存器是默认的，比如以下指令，段地址默认在ds中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ax,[0]<br>mov ax,[di]<br>mov ax,[bx+8]<br>mov ax,[bx+si]<br>mov ax,[bx+si+8]<br></code></pre></td></tr></table></figure>
<p>段地址默认在ss中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ax,[bp]<br>mov ax,[bp+8]<br>mov ax,[bp+si]<br>mov ax,[bp+si+8]<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="8-4-寻址方式"><a href="#8-4-寻址方式" class="headerlink" title="8.4 寻址方式"></a>8.4 寻址方式</h2><p><img src="/images/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/efb17885fa7dfbc1.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="8-5-指令要处理得到数据有多长"><a href="#8-5-指令要处理得到数据有多长" class="headerlink" title="8.5 指令要处理得到数据有多长"></a>8.5 指令要处理得到数据有多长</h2><ol>
<li><p>通用寄存器指明要处理的数据的尺寸</p>
</li>
<li><p>没有寄存器名存在时，<strong>用操作符X ptr指明内存单元的长度，X可以为byte或word</strong></p>
</li>
<li><p>push不用指明访问子单元还是字节单元，push指令只进行字操作</p>
</li>
</ol>
<h2 id="8-7-div指令"><a href="#8-7-div指令" class="headerlink" title="8.7 div指令"></a>8.7 div指令</h2><ol>
<li><p>除数: 有8位和16位，在一个reg或内存单元中</p>
</li>
<li><p>被除数：默认放在 AX 或 DX 中，除数为 8 位，被除数则为 16 位，默认在 AX 中存放；除数为 16 位，被除数则为 32 位，在 DX 和 AX 中存放，DX 存放高16位，AX 存放低 16 位</p>
</li>
<li><p>结果：除数为 8 位，则 AL 存储除法操作的商，AH 存储除法操作的余数；</p>
</li>
</ol>
<p>​ 除数为16位，AX 存储商，DX 存储余数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">div reg<br>div 内存单元<br></code></pre></td></tr></table></figure>
<p>用多种方法表示一个内存单元</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">div byte ptr ds:[0]<br>;(al)=(ax)/((ds)*16+0)的商<br>;(ah)=(ax)/((ds)*16+0)的余数<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">div word ptr es:[0]<br>;(ax)=[(dx)*10000H+(ax)]/((ex)*16+0)的商<br>;(bx)=[(dx)*10000H+(ax)]/((ex)*16+0)的余数<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">div byte ptr [bx+si+8]<br>;(al)=(ax)/((ds)*16+(si)+8)的商<br>;(ah)=(ax)/((ds)*16+(si)+8)的余数<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">div word ptr [bx+si+8]<br>;(ax)=[(dx)*10000H+(ax)]/((ds)+(si)+8)的商<br>;(dx)=[(dx)*10000H+(ax)]/((ds)+(si)+8)的余数<br></code></pre></td></tr></table></figure>
<p>利用除法指令计算100001&#x2F;100</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asm">被除数100001大于65535，不能用于ax寄存器存放，用dx和ax两个寄存器联合存放100001，除数小于255，用8位寄存器存放<br>mov dx,1<br>mov ax,86A1H<br>mov bx,100<br>div bx<br>;(ax)=03E8H,(dx)=1<br></code></pre></td></tr></table></figure>
<h2 id="8-8-伪指令-dd"><a href="#8-8-伪指令-dd" class="headerlink" title="8.8 伪指令 dd"></a>8.8 伪指令 dd</h2><p>dd用来定义dword(double word,双字)型整数</p>
<p>用div计算data段中第一个数据除以第二个数据后的结果，商存在第三个数据存储单元中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asm">data segment<br>	dd 100001<br>	dw 100<br>	dw 0<br><br>	mov ax,data<br>	mov ds,ax<br>	mov ax,ds:[0]				;ds:0字单元中的低16位存储在ax中<br>	mov dx,ds:[2]				;ds:0字单元中的高16位存储在dx中<br>	div word ptr ds:[4]			;dx:ax中的32位数据除以ds:4字单元中的数据<br>	mov ds:[6],ax				;存储<br><br>data ends<br></code></pre></td></tr></table></figure>

<h2 id="8-9-dup"><a href="#8-9-dup" class="headerlink" title="8.9 dup"></a>8.9 dup</h2><p>操作符，由编译器识别处理，用来进行数据的重复</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm">db 3 dup (0)				;定义3个字节，值为0，相当于db 0,0,0<br><br>db 3 dup (0,1,2)			;定义9个字节，0、1、2、0、1、2、0、1、2，相当于db 0,1,2,0,1,2,0,1,2<br><br>db 3 dup (&#x27;abc&#x27;,&#x27;ABC&#x27;)		;定义18个字节，‘abcABCabcABCabcABC’,相当于db &#x27;abcABCabcABCabcABC&#x27;<br></code></pre></td></tr></table></figure>
<p>dup使用格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">db 重复的次数 dup(重复的字节型数据)<br>dw 重复的次数 dup(重复的字型数据)<br>dd 重复的次数 dup(重复的双字型数据)<br></code></pre></td></tr></table></figure>
<h1 id="九、转移指令的原理"><a href="#九、转移指令的原理" class="headerlink" title="九、转移指令的原理"></a>九、转移指令的原理</h1><p>可以修改IP，同时修改CS和IP的指令</p>
<p>8086CPU转移行为分为两类</p>
<ul>
<li><strong>只修改IP，称为段内转移</strong>，比如：jmp 1000:0</li>
<li><strong>同时修改CS和IP时，称为段间转移</strong>，比如：jmp 1000:0</li>
</ul>
<p><strong>段间转移分为：短转移和近转移</strong></p>
<ul>
<li>短转移IP修改范围为-128-127</li>
<li>近转移2IP修改范围为-32768-32767<br>8086CPU转移指令：</li>
<li>无条件转移指令（如：jmp）</li>
<li>条件转移指令</li>
<li>循环指令</li>
<li>过程</li>
<li>中断</li>
</ul>
<h2 id="9-1-操作符offset"><a href="#9-1-操作符offset" class="headerlink" title="9.1 操作符offset"></a>9.1 操作符offset</h2><p>操作符offset由编译器处理，取得标号的偏移地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:codesg<br>codesg segment<br>start:	mov ax,offset start				;相当于mov ax,0<br>	s:	mov ax,offset s					;相当于mov ax,3<br>codesg ends<br>end start<br>//start所标记的指令是代码段的第一条指令，偏移地址为0<br>//s所标记的指令为第二条，第一条指令字节长度为3个字节，则s的偏移地址为3<br></code></pre></td></tr></table></figure>
<p>e.g 使程序在运行中将s处的第一条指令复制到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asm">//将s处的指令复制到s0处就是将cs:offset s复制到cs:offset s0<br>assume cs:codesg<br>codesg segment<br>	s:	mov ax,bx<br>		mov si,offset s<br>		mov di,offset s0<br>		mov ax,cs:[si]<br>		mov cs:[di],ax<br>	s0:	nop<br>		nop<br>codesg ends<br>end s<br></code></pre></td></tr></table></figure>
<h2 id="9-2-jmp指令"><a href="#9-2-jmp指令" class="headerlink" title="9.2 jmp指令"></a>9.2 jmp指令</h2><p>无条件转移指令</p>
<p>jmp指令给出两种信息：</p>
<ul>
<li>转移的目的地址</li>
<li>转移的距离（段间转移、段内短转移、段内近转移）</li>
</ul>
<h2 id="9-3-根据位移进行转移的jmp指令"><a href="#9-3-根据位移进行转移的jmp指令" class="headerlink" title="9.3 根据位移进行转移的jmp指令"></a>9.3 根据位移进行转移的jmp指令</h2><ul>
<li>jmp short 标号（转到标号处执行指令）	;段内短转移</li>
<li>CPU 在执行 jmp 指令时不需要转移的目的地址</li>
<li><strong>“jmp short 标号“功能:(IP)&#x3D;(IP)+8位位移</strong><ol>
<li>8位位移&#x3D;标号处的地址-jmp 指令后的第一个字节的地址</li>
<li>short 指明此处的位移为8位位移</li>
<li>8位位移范围为-128~127，用补码表示</li>
<li>8位位移由编译程序在编译时算出</li>
</ol>
</li>
<li><strong>jmp near ptr 标号”:(IP)&#x3D;(IP)+16 位位移</strong><ol>
<li>16位位移&#x3D;标号处的地址-jmp指令的第一个字节的地址</li>
<li>near ptr 指明此处的位移为16位位移</li>
<li>16位位移范围为-32768~32767，用补码表示</li>
<li>16位位移由编译程序在编译时算出</li>
</ol>
</li>
</ul>
<h2 id="9-4-转移的目的地址在指令中的jmp指令"><a href="#9-4-转移的目的地址在指令中的jmp指令" class="headerlink" title="9.4 转移的目的地址在指令中的jmp指令"></a>9.4 转移的目的地址在指令中的jmp指令</h2><p>“jmp far ptr 标号”实验<strong>段间转移，又称远转移</strong></p>
<ul>
<li>(cs)&#x3D;所在标号的段地址</li>
<li>(ip)&#x3D;所在标号的偏移地址</li>
<li>far ptr 指明了指令用标号的段地址和偏移地址修改cs和ip</li>
</ul>
<h2 id="9-5-转移地址在寄存器的jmp指令"><a href="#9-5-转移地址在寄存器的jmp指令" class="headerlink" title="9.5 转移地址在寄存器的jmp指令"></a>9.5 转移地址在寄存器的jmp指令</h2><p>格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">jmp 16位reg<br></code></pre></td></tr></table></figure>
<p>功能: (IP)&#x3D;(16位reg)</p>
<h2 id="9-6-转移地址在内存中的jmp指令"><a href="#9-6-转移地址在内存中的jmp指令" class="headerlink" title="9.6 转移地址在内存中的jmp指令"></a>9.6 转移地址在内存中的jmp指令</h2><ol>
<li><strong>jmp word ptr 内存单元地址(段内转移)</strong></li>
</ol>
<ul>
<li>只修改ip</li>
<li>从内存单元地址处开始存放一个字，是转移的目的偏移地址</li>
<li>内存单元地址可用寻址方式的任一格式给出</li>
<li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ax,0123H<br>mov ds:[0],ax<br>jmp word ptr ds:[0]				;执行后(IP)=0123H<br><br>mov ax,0123H<br>mov [bx],ax<br>jmp word ptr [bx]				;执行后值为0123H,(IP)=0123H<br></code></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><strong>jmp dword ptr 内存单元地址(段间转移)</strong></li>
</ol>
<ul>
<li>只修改cs和ip</li>
<li>从内存单元开始存放两个字，<strong>高地址处的字是转移的目的段地址，低地址处的字是转移目的地址的偏移地址</strong></li>
<li>(cs)&#x3D;(内存单元地址+2)</li>
<li>(ip)&#x3D;(内存单元地址)</li>
<li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ax,0123H<br>mov ds:[0],ax<br>mov word ptr ds:[2],0<br>jmp dword ptr ds:[0]			;执行后值为0000 0123H,因为mov word ptr ds:[2],0所以其高16位为0，段地址(cs)=0,mov ds:[0]为0123H，低16位偏移地址(ip)=0123H<br></code></pre></td></tr></table></figure>
e.g 使jmp指令执行后，cs:ip指向程序的第一条指令(重启程序)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:code<br>date segment<br>	dd 12345678H<br>data ends<br>code segment<br>start:	mov ax,data<br>		mov ds,ax<br>		mov bx,0<br>		mov [bx],bx				;或者 mov [bx],word ptr 0 或者 mov [bx],offset start<br>		;将IP设置为0<br>		mov [bx+2],cs			;或者 mov [bx+2],seg code<br>		;将cs段地址放入内存单元<br>		jmp dword ptr ds:[0]<br>code ends<br>end start<br>;jmp dword ptr ds:[0]为段间转移，(cs)=(内存单元地址+2),(IP)=(内存单元地址)<br>;CS:IP指向第一条指令，第一条程序地址为CS:0。设置CS:IP指向cs:0<br></code></pre></td></tr></table></figure>
e.g 2000:1000 BE 00 06 00 00 00 …<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ax,2000H<br>mov es,ax<br>jmp dword ptr es:[1000H]<br>;执行后:(cs)=0006H,(ip)=00BEH<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="9-7-jcxz指令"><a href="#9-7-jcxz指令" class="headerlink" title="9.7 jcxz指令"></a>9.7 jcxz指令</h2><p>jcxz指令为有<strong>条件转移指令，都是短转移</strong>,在对应的机器码中包含转移的位移，而不是目的地址。IP修改范围为:-128-127</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">jcxz 标号((cx)=0),转移到标号处执行<br>当(cx)=0,(IP)=(IP)+8位位移<br></code></pre></td></tr></table></figure>
<ul>
<li>8位位移&#x3D;标号处的地址-jcxz指令后的第一个字节的地址</li>
<li>8位位移的范围为-128~127，用补码表示<br>“jcxz标号”功能相当于:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">if((cx)==0)<br>	jmp short 标号<br></code></pre></td></tr></table></figure>
e.g 利用jcxz指令，实现在内存2000H段中查找第一个值为0的字节，找到后将它的偏移地址存储在 dx 中<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:code<br>code segment<br>start:	mov ax,2000H<br>		mov ds,ax<br><br>		mov bx,0<br>	s:	mov ch,0				;将ch寄存器清零。ch寄存器被用作辅助寄存器，cx寄存器由ch和cl组成,用于循环计数<br>		mov cl,[bx]				;将bx指向的内存地址的内容送入cl<br>		jcxz ok					;if(cx==0),就是ch和cl为0<br>		inc bx<br>		jmp short s<br><br>	ok:	mov dx,bx<br>		mov ax,4c00H<br>		int 21H<br>code ends<br>end start<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="9-8-loop指令"><a href="#9-8-loop指令" class="headerlink" title="9.8 loop指令"></a>9.8 loop指令</h2><p>loop指令为循环指令,<strong>所有循环指令都是短转移</strong><br>格式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">loop 标号 (cx)=(cx)-1,如果(cx)!=0,转移到标号处执行<br>即:<br>	(cx)=(cx)-1<br>	如果(cx)不为0，(ip)=(ip)+8位位移<br></code></pre></td></tr></table></figure>
<ul>
<li>8位位移&#x3D;标号处地址 - loop 指令后的第一个字节的地址</li>
<li>8位位移的范围为-128~127，用补码表示<br>“loop”相当于:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">	(cx)--<br>if((cx)!=0)<br>		jmp short 标号<br></code></pre></td></tr></table></figure>
e.g 利用 loop 指令，实现在内存 2000H 段中查找第一个值为 0 的字节，将偏移地址存储在 dx 中<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:code<br>code segment<br>start:	mov ax,2000H<br>		mov ds,ax<br>		mov bx,0<br>	s:	mov cl,[bx]<br>		mov ch,0<br>		inc cx<br>		inc bx<br>		loop s<br>	ok:	dec bx<br>	mov dx,bx				;dec和inc相反，dec bx 进行操作为:(bx)=(bx)-1<br>		mov ax,4c00H<br>		int 21H<br>code ends<br>end start<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="十、CALL和RET指令"><a href="#十、CALL和RET指令" class="headerlink" title="十、CALL和RET指令"></a>十、CALL和RET指令</h1><h2 id="10-1-ret和retf"><a href="#10-1-ret和retf" class="headerlink" title="10.1 ret和retf"></a>10.1 ret和retf</h2><p>ret 指令用栈中的数据，修改 IP 的内容，从而实现转移</p>
<p>retf 修改 CS 和 IP 的内容，实现转移</p>
<p>执行 ret 指令时 : 相当于进行：pop IP</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">(ip)=((ss)*16+(sp))<br>(sp)=(sp)+2<br></code></pre></td></tr></table></figure>
<p>执行 retf 指令时：相当于进行：pop IP pop CS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">(IP)=((ss)*16+(sp))<br>(sp)=(sp)+2<br>(CS)=((ss)*16+(sp))<br>(sp)=(sp)+2<br></code></pre></td></tr></table></figure>
<p>ret 指令执行后，(IP)&#x3D;0,CS:IP 指向代码段的第一条指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:code<br>stack segment<br>	db 16 dup(0)<br>stack ends<br>code segment<br>		mov ax,4c00h<br>		mov 21h<br>start:	mov ax,stack<br>		mov ss,ax<br>		mov sp,16<br>		mov ax,0<br>		push ax<br>		mov bx,0<br>		ret<br>code ends<br>end start<br></code></pre></td></tr></table></figure>

<p>retf 指令执行后，CS:IP 指向代码段的第一条命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:code<br>stack segment<br>	db 16 dup(0)<br>stack ends<br>code segment<br>		mov ax,4c00h<br>		int 21h<br>start:	mov ax,stack<br>		mov ss,ax<br>		mov sp,16<br>		mov ax,0<br>		push cx<br>		push ax<br>		mov bx,0<br>		retf<br>code ends<br>end start<br></code></pre></td></tr></table></figure>
<p>e.g 实现从内存 1000:0000 处开始执行指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:code<br>stack segment<br>	db 16 dup(0)<br>stack ends<br>code segment<br>start:	mov ax,stack<br>		mov ss,ax<br>		mov sp,10h<br>		mov ax,1000h<br>		push ax<br>		mov ax,0<br>		push ax<br>		retf<br>code ends<br>end start<br>;先将段地址cs入栈，再将偏移地址ip入栈<br></code></pre></td></tr></table></figure>
<h2 id="10-3-根据位移进行转移的call指令"><a href="#10-3-根据位移进行转移的call指令" class="headerlink" title="10.3 根据位移进行转移的call指令"></a>10.3 根据位移进行转移的call指令</h2><p>CPU 执行 call 指令时，进行：</p>
<ul>
<li>将当前ip或cs或ip压入栈</li>
<li>转移</li>
</ul>
<p>**call标号(将当前ip压栈后，转到标号处执行指令)</p>
<p>执行call指令时，进行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">(sp)=(sp)-2<br>((ss)*16+(sp))=(ip)<br>(ip)=(ip)+16位位移<br></code></pre></td></tr></table></figure>
<ul>
<li>16位位移 &#x3D; 标号处的地址 - call 指令后的第一个字节的地址</li>
<li>16位位移的范围为-32768~32767<br>执行 “ call 标号 “时，相当于进行：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">push ip<br>jmp near ptr 标号<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="10-4-转移的目的地址在指令中的call指令"><a href="#10-4-转移的目的地址在指令中的call指令" class="headerlink" title="10.4 转移的目的地址在指令中的call指令"></a>10.4 转移的目的地址在指令中的call指令</h2><p>“call far ptr 标号” 实现段间转移<br>执行时:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asm">1) (sp)=(sp)-2<br>	((ss)*16+(sp))=(CS)<br>	(sp)=(sp)-2<br>	((ss)*16+(sp))=(IP)<br>2) (CS)=标号所在段的段地址<br>	(IP)=标号在段中的偏移地址<br></code></pre></td></tr></table></figure>
<p>执行”call far ptr 标号”时，相当于:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">push cs<br>push ip<br>jmp far ptr 标号<br></code></pre></td></tr></table></figure>
<h2 id="10-5-转移地址在寄存器中的call指令"><a href="#10-5-转移地址在寄存器中的call指令" class="headerlink" title="10.5 转移地址在寄存器中的call指令"></a>10.5 转移地址在寄存器中的call指令</h2><p>格式:call 16位reg</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asm">	(sp)=(sp)-2<br>	((ss)*16+(sp))=(IP)<br>	(IP)=(16位reg)<br>;相当于<br>	push IP<br>	jmp 16位reg<br></code></pre></td></tr></table></figure>
<h2 id="10-6-转移地址在内存中的call指令"><a href="#10-6-转移地址在内存中的call指令" class="headerlink" title="10.6 转移地址在内存中的call指令"></a>10.6 转移地址在内存中的call指令</h2><h3 id="1-call-word-ptr-内存单元地址"><a href="#1-call-word-ptr-内存单元地址" class="headerlink" title="1) call word ptr 内存单元地址"></a>1) call word ptr 内存单元地址</h3><p>相当于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">push ip<br>jmp word ptr 内存单元地址<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov sp,10h<br>mov ax,0123h<br>mov ds:[0],ax<br>call word ptr ds:[0]				;(ip)=0123h,(sp)=0Eh<br></code></pre></td></tr></table></figure>
<h3 id="2-call-dword-ptr-内存单元地址"><a href="#2-call-dword-ptr-内存单元地址" class="headerlink" title="2) call dword ptr 内存单元地址"></a>2) call dword ptr 内存单元地址</h3><p>相当于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">push cs<br>push ip<br>jmp dword ptr 内存单元地址<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov sp,10h<br>mov ax,0123h<br>mov ds:[0],ax<br>mov word ptr ds:[2],0<br>call dword ptr ds:[0]				;进行两次压栈操作，sp-2-2,(cs)=0,(ip)=0123h,(sp)=0ch<br></code></pre></td></tr></table></figure>
<p>e.g 下面程序执行后，ax 和 bx 值为多少</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:code<br>data segment<br>	dw 8 dup(0)<br>data ends<br>code segment<br>start:	mov ax,data				;3字节<br>		mov ss,ax				;2字节<br>		mov sp,10h				;3字节<br>		mov word ptr ss:[0],offset s				;7字节<br>		;ss:[0]=1ah<br><br>		mov ss:[2],cx			;4字节<br>		;ss:[2]=cs<br><br>		call dword ptr ss:[0]				;7字节<br><br>		nop<br>	s:	mov ax,offset s<br>		sub ax,ss:[0ch]				;4字节<br><br>		mov bx,cs<br>		sub bx,ss:[0eh]				;4字节<br>		mov ax,4c00h<br>		int 21h<br>code ends<br>end start<br></code></pre></td></tr></table></figure>
<h2 id="10-7-call-和-ret-的配合使用"><a href="#10-7-call-和-ret-的配合使用" class="headerlink" title="10.7 call 和 ret 的配合使用"></a>10.7 call 和 ret 的配合使用</h2><p>e.g bx的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:code<br>code segment<br>start:	mov ax,1<br>		mov cx,3<br>		call s				;ip指向下一条指令，并压栈，将ip的值改为标号为s处的偏移地址<br><br>		mov bx,ax<br><br>		mov ax,4c00h<br>		int 21h<br>	s:	add ax,ax<br>		loop s				;ax=8<br>		ret					;前面压入的指令的偏移地址送入ip中。cs:ip指向mov bx,ax,从此开始执行命令。bx=8<br>code ends<br>end start<br></code></pre></td></tr></table></figure>
<h2 id="10-8"><a href="#10-8" class="headerlink" title="10.8"></a>10.8</h2><ul>
<li>mul 是乘法指令</li>
<li>两个相乘的数位要一样，<strong>8位默认放在 AL</strong> 中，另一个放在8位 reg 或内存字节单元中；<strong>16位放在AX</strong>中，另一个放在16位 reg 或内存字单元中。</li>
<li>8位乘法，结果默认放在 AX 中；16位，结果高位默认在 DX 中，低位 AX 中。<br>格式:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">mul reg<br>mul 内存单元<br></code></pre></td></tr></table></figure>
内存单元可以用不同的寻址方式给出,比如:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">mul byte ptr ds:[0]				;(ax)=(al)*((ds)*16+0)<br><br>mul word ptr ds:[bx+si+8]		;(ax)=(ax)*((ds)*16+(bx)+(si)+8)结果的低16位,(dx)=(ax)*((ds)*16+(bx)+(si)+8)结果的高16位<br></code></pre></td></tr></table></figure>
e.g 计算100*10<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ax,100<br>mov bl,10<br>mul bl				;(ax)=03E8h<br></code></pre></td></tr></table></figure>
e.g 100*10000<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ax,100<br>mov bx,10000<br>mul bx				;(ax)=4240h,(dx)=000fh<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="10-10-参数和结果传递的问题"><a href="#10-10-参数和结果传递的问题" class="headerlink" title="10.10 参数和结果传递的问题"></a>10.10 参数和结果传递的问题</h2><p>e.g 计算data 段中的第一组数据的3次方，结果保存在后面一组dword单元中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:code<br>data segment<br>	dw 1,2,3,4,5,6,7,8<br>	dd 8 dup(0)<br>data ends<br>code segment<br>start:	mov ax,data<br>		mov ds,ax<br>		mov si,0				;ds:si指向第一组word单元<br>		mov di,16				;ds:di指向第二组dword单元<br><br>		mov cx,8<br>s:		mov bx,[si]<br>		call cube<br>		mov [si],ax<br>		mov [di].2,ds<br>		add si,2				;ds:si 指向下一个word单元<br>		add di,4				;ds:di 指向下一个dword单元<br>		loop s<br><br>		mov ax,4c00h<br>		int 21h<br>cube:	mov ax,bx<br>		mul bx<br>		mul bx<br>		ret<br>code ends<br>end start<br></code></pre></td></tr></table></figure>

<h1 id="十一、标志寄存器"><a href="#十一、标志寄存器" class="headerlink" title="十一、标志寄存器"></a>十一、标志寄存器</h1><p>标志寄存器flag按位起作用<br><img src="/images/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/b4e62b03ac53ddf3.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="11-1-ZF标志-Zero-Flag"><a href="#11-1-ZF标志-Zero-Flag" class="headerlink" title="11.1 ZF标志(Zero Flag)"></a>11.1 ZF标志(Zero Flag)</h2><p>flag的第6位是ZF，零标志位。如果执行相关指令后，结果为0，ZF&#x3D;1;不为0，ZF&#x3D;0。</p>
<h2 id="11-2-PF标志-Parity-Flag"><a href="#11-2-PF标志-Parity-Flag" class="headerlink" title="11.2 PF标志(Parity Flag)"></a>11.2 PF标志(Parity Flag)</h2><p>flag的第二位是PF，奇偶标志位。记录相关指令执行后，结果的所有bit位中1的个数是否为偶数，如果是偶数，PF&#x3D;1,如果是奇数，PF&#x3D;0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov al,1<br>add al,10				;00001011b,3个1，PF=0<br>mov al,1<br>or al,2					;00000011b,两个1，PF=1<br>sub al,al				;00000000b,零个1，PF=1<br></code></pre></td></tr></table></figure>
<h2 id="11-3-SF标志-Sign-Flag"><a href="#11-3-SF标志-Sign-Flag" class="headerlink" title="11.3 SF标志(Sign Flag)"></a>11.3 SF标志(Sign Flag)</h2><p>flag第7位，符号标志位。记录执行指令后，结果是否为负。结果为负,SF&#x3D;1;如果非负,SF&#x3D;0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asm">sub al,al				;ZF=1,PF=1,SF=0<br>muv al,1				;	1	1	0<br>push ax					;	1	1	0<br>pop	bx					;	1	1	0<br>;mov,push,pop等传送指令对标志寄存器没影响<br>add al,bl				;	0	0	0<br>add al,10				;	0	1	0	<br>mul al					;	0	1	0<br></code></pre></td></tr></table></figure>
<h2 id="11-4-CF标志-Carry-Flag"><a href="#11-4-CF标志-Carry-Flag" class="headerlink" title="11.4 CF标志(Carry Flag)"></a>11.4 CF标志(Carry Flag)</h2><p>flag 第 0 位是 CF，进位标志位。一般情况下，在进行无符号运算时，记录了运算结果的最高有效位向跟高位的进位值，或从更高位的借位值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov al,98H<br>add al,al		;(al)=30H,CF=1,CF记录了从最高有效位向跟高位的进位值<br>add al,al		;(al)=60H,CF=0<br><br>mov al,97H<br>sub al,98H		;(al)=FFH,CF=1，CF记录了向更高位的借位值<br>sub al,al		;(al)=0,CF=0<br></code></pre></td></tr></table></figure>

<h2 id="11-5-OF标志-Overflow-Flag"><a href="#11-5-OF标志-Overflow-Flag" class="headerlink" title="11.5 OF标志(Overflow Flag)"></a>11.5 OF标志(Overflow Flag)</h2><p>flag第11位是OF，溢出标志位。OF记录有符号数运算的结果是否发生溢出。溢出OF&#x3D;1没有OF&#x3D;0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov al,0f0h<br>add al,88h				;执行后，有符号运算时，0f0h+88h=-16+(-120),负溢出OF=1;无符号运算,0F0H+88H有进位,CF=1<br><br>mov al,0f0h<br>add al,78h				;执行后，有符号运算时，0f0h+78h=-16+120,无溢出OF=0;无符号运算0F0H+78H有进位,CF=1<br></code></pre></td></tr></table></figure>
<p>e.g 下列每条指令执行后，ZF 、PF、SF、CF、OF等标志位的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asm">sub al,al				;ZF=1,PF=1,SF=0,CF=0,OF=0<br>mov al,10h				;	1	1	0	0	0<br>add al,90h				;	0	1	1	0	0<br>mov al,80h				;	0	1	1	0	0<br>add al,80h				;	1	1	0	1	1<br>mov al,0fch				;	1	1	0	1	1<br>add al,05h				;	0   0	0	1	0<br>mov al,7dh				;	0	0	0	1	0<br>add al,0bh				;	0	1	1	0	1<br></code></pre></td></tr></table></figure>
<h2 id="11-6-adc指令"><a href="#11-6-adc指令" class="headerlink" title="11.6 adc指令"></a>11.6 adc指令</h2><h3 id="adc-为带进位加法指令"><a href="#adc-为带进位加法指令" class="headerlink" title="adc 为带进位加法指令"></a>adc 为带进位加法指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">格式:	adc 操作对象1,操作对象2<br>功能:	操作对象1 = 操作对象1 + 操作对象2 + CF<br>;指令:	adc ax,bx<br>;(ax)=(ax)+(bx)+CF<br></code></pre></td></tr></table></figure>
<p>e.g</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ax,2<br>mov bx,1<br>sub bx,ax<br>adc ax,1				;(ax)=4,(ax)+1+CF=4<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ax,1<br>add ax,ax<br>adc ax,3				;(ax)=2+3+CF=5<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov al,98h<br>add al,al<br>adc al,3				;(ax)=30h+3+CF=34h<br></code></pre></td></tr></table></figure>
<p><strong>执行adc指令时，CF的值如果是被sub指令设置的，那么就是借位值，add指令设置时，是进位值</strong><br>加法可以分两部进行:</p>
<ul>
<li>低位相加，比如0198h和0183h。低位相加得1bh</li>
<li>高位相加再加上低位相加的进位值。01+01+1&#x3D;03</li>
</ul>
<p>e.g 计算 001E F000 1000H + 0020 1000 1EF0H，结果放在 ax(最高 16 位)，bx(次高 16 位)，cx(低 16 位)中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ax,001EH<br>mov bx F000H<br>mov cx,1000H<br>add ax,0020H<br>add bx,1000H<br>add cx,1EF0H<br></code></pre></td></tr></table></figure>
<h2 id="11-7-sbb指令"><a href="#11-7-sbb指令" class="headerlink" title="11.7 sbb指令"></a>11.7 sbb指令</h2><p><strong>sbb是带借位减法指令，利用CF位上记录的借位值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">sbb 操作对象1,操作对象2<br>操作对象1 = 操作对象1 - 操作对象2 - CF<br>;sbb ax,bx<br>;(ax)=(ax) - (bx) - CF<br></code></pre></td></tr></table></figure>
<p>e.g 计算 003E 1000H - 0020 2000H,结果放在ax,bx中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov bx,1000H<br>mov ax,003EH<br>sub bx,2000H<br>sbb ax,0020H<br></code></pre></td></tr></table></figure>

<h2 id="11-8-cmp指令"><a href="#11-8-cmp指令" class="headerlink" title="11.8 cmp指令"></a>11.8 cmp指令</h2><p><strong>cmp 为比较指令，相当于减法，但不保存结果。执行后会对标志寄存器产生影响。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">格式:	cmp 操作对象1,操作对象2<br>功能:	计算操作对象1 - 操作对象2，不保存结果，仅仅根据计算结果对标志寄存器进行设置<br>;cmp ax,ax<br>;结果为0，指令执行后 ZF=1,PF=1,SF=0,CF=0,OF=0<br></code></pre></td></tr></table></figure>
<h2 id="对于cmp-ax-bx，有如下分析"><a href="#对于cmp-ax-bx，有如下分析" class="headerlink" title="对于cmp ax,bx，有如下分析"></a><strong>对于cmp ax,bx，有如下分析</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs asm">if(ax==bx),(ax)-(bx) = 0,ZF=1<br>if(ax!=bx),(ax)-(bx)!=0,ZF=0<br>if(ax&lt;bx),(ax)-(bx)&lt;0,产生借位,CF=1<br>if(ax&gt;=bx),(ax)-(bx)&gt;=0,CF=0<br>if(ax&gt;bx),(ax)-(bx)&gt;0,CF=0 且 ZF=0<br>if(ax&lt;=bx),(ax)-(bx)&lt;=0,CF=1 或 ZF=1<br><br>if:<br>	ZF=1,说明(ax)=(bx)<br>	ZF=0,(ax)!=(bx)<br>	CF=1,(ax)&lt;(bx)<br>	CF=0,(ax)&gt;(bx)<br>	CF=0 且 ZF=0,(ax)&gt;(bx)<br>	CF=1 或 ZF=1,(ax)&lt;=(bx)<br></code></pre></td></tr></table></figure>

<p>对有符号数进行比较时</p>
<p><strong>对于	cmp ah,bh</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">if(ah==bh),(ah)-(bh)=0,ZF=1<br>if(ah!=bh),(ah)-(bh)!=0,ZF=0<br></code></pre></td></tr></table></figure>
<p>1.如果SF&#x3D;1,OF&#x3D;0<br>OF&#x3D;0,没有溢出，逻辑上真正结果的正负&#x3D;实际结果的正负<br>SF&#x3D;1,实际结果为负数，所以逻辑上真正的结果为负，(ah)&lt;(bh)</p>
<p>2.如果 sf &#x3D;1，of &#x3D;1<br>OF &#x3D;1，有溢出，逻辑上真正结果的正负与实际结果的正负不相等<br>SF &#x3D;1，实际结果为负<br><strong>如果因为溢出导致实际结果为负，那么逻辑上真正的结果为正(ah)&gt;(bh)</strong></p>
<p>3.如果 sf &#x3D; 0,of &#x3D; 1<br>SF&#x3D;0，实际结果为非负，而 OF &#x3D;1 说明有溢出 ，结果为非 0 ，实际结果为正<br><strong>如果因为溢出导致实际结果为非负，那么逻辑上真正结果为负，(ah)&lt;(bh)</strong></p>
<p>4.sf &#x3D;0,of &#x3D;0<br>没有溢出，实际结果为非负，(ah)&gt;&#x3D;(bh)</p>
<h2 id="11-9-检测比较结果的条件转移指令"><a href="#11-9-检测比较结果的条件转移指令" class="headerlink" title="11.9 检测比较结果的条件转移指令"></a>11.9 检测比较结果的条件转移指令</h2><p>“转移”指它能修改IP,”条件”指它可以根据某种条件，决定是否修改IP</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
<th>检测的相关标志位</th>
</tr>
</thead>
<tbody><tr>
<td>je</td>
<td>等于则转移</td>
<td>ZF &#x3D; 1</td>
</tr>
<tr>
<td>jne</td>
<td>不等于则转移</td>
<td>ZF &#x3D; 0</td>
</tr>
<tr>
<td>jb</td>
<td>低于则转移</td>
<td>CF &#x3D; 1</td>
</tr>
<tr>
<td>jnb</td>
<td>不低于则转移</td>
<td>CF &#x3D; 0</td>
</tr>
<tr>
<td>ja</td>
<td>高于则转移</td>
<td>CF &#x3D; 0 且 ZF &#x3D; 0</td>
</tr>
<tr>
<td>jna</td>
<td>不高于则转移</td>
<td>CF &#x3D; 1 或 ZF &#x3D; 1</td>
</tr>
</tbody></table>
<p>e.g 统计data段中数值小于8的字节个数,用ax保存统计结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asm">		mov ax,data<br>		mov ds,ax<br>		mov ax,0<br>		mov bx,0<br>		mov cx,9<br>s:	cmp byte ptr [bx],8<br>		jnb next<br>		inc ax<br>next:	inc bx<br>		loop s<br></code></pre></td></tr></table></figure>
<p>统计F000:0处32个字节中，大小在[32,128]的数据个数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asm">		mov ax,f000h<br>		mov ds,ax<br>		mov bx,0<br>		mov dx,0<br>		mov cx,32<br>s:		mov al,[bx]<br>		cmp al,32<br>		jb s0<br>		cmp al,128<br>		jae s0<br>		inc bx<br>s0:		inc bx<br>		loop s<br></code></pre></td></tr></table></figure>



                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Reverse/" class="category-chain-item">Reverse</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%AD%A6%E4%B9%A0/" class="print-no-link">#学习</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>汇编学习</div>
      <div>https://wjg-666.github.io/2025/10/30/汇编学习/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>wjg</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月30日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/11/05/ctf_show_reverse/" title="ctf_show Reverse部分的题目复现">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">ctf_show Reverse部分的题目复现</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/29/hello-world/" title="Hello World">
                        <span class="hidden-mobile">Hello World</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"Si1PQUTYPX1DeZCU0JiicTH0-gzGzoHsz","appKey":"EMxTCg3lvdJ3026UxKY3sACf","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        var texts = ["Hi, 这里是 Wjg 的小站","代码 | 生活 | 记录"];
        var idx = Math.floor(Math.random() * texts.length);
        typing(texts[idx]);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
